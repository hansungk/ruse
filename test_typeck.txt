// TODO:

struct Car {
    engine: int,
    wheel: int,
    gear: &int,
}

func void_ret() {
    return 1 // ERROR: function .* should not return
}

func f() -> Car {
    return 0 // ERROR: return type mismatch
    if 1 {
      0
    } else if 2 {
      0
      1
    }
}

func g() -> int {
    return 98
}

func h(a: int, b: &int) -> int {
    return 1
}

func main() {
    // var decl and assignment
    var s: string
    s = "hi"
    var car: Car
    car = 3 // ERROR: cannot assign 'int'.*'Car'

    // immutability
    var immut = 4
    immut = "nope" // ERROR: cannot assign .* to 'int'

    // member access
    3.engine // ERROR: 'int'.*not a struct
    car.wing // ERROR: 'wing'.*not.*member.*'Car'
    car.engine

    car.engine = car // ERROR: cannot assign 'Car'.*'int'
    *(car.gear) = 4

    // binary expressions
    (3 + car) // ERROR: incompatible.*binary.*'int'.*'Car'
    (3 + car).wheel // ERROR: incompatible.*binary.*'int'.*'Car'
    (car).wheel

    // function calls
    car = f()
    var i: int
    i = f() // ERROR: cannot assign 'Car'.*'int'
    f() + g() // ERROR: incompatible.*binary.*'Car'.*'int'
    f().engine
    f().wing // ERROR: 'wing'.*not.*member.*'Car'
    h(3, 4) // ERROR: argument type mismatch
    void_ret()
    i = void_ret() // ERROR: cannot assign 'void' .* 'int'
    
    // paren expr
    (f()).engine
    i = 3 + 4

    // ref and deref
    *i // ERROR: dereference.*'int'
    var ptr: &int
    *ptr = 3
    *ptr = car // ERROR: cannot assign 'Car'.*'int'
    ptr = &i
    &24 // ERROR: take address of an rvalue
    &g() // ERROR: take address of an rvalue

    let pcar: &Car
    (*pcar).wheel
    *(pcar.wheel) // ERROR: '&Car' is not a struct

    // others that skip typeck
    #printf("hello, world\n")
}
