// TODO:
// struct member check

struct Car {
    engine: int,
    wheel: int,
}

func f() -> Car {
    return 0 // [error: "return type mismatch"]
    if 1 {
    } else if 2 {
    }
}

func g() -> int {
}

func h(a: int, b: *int) -> int {
}

func main() {
    // var decl and assignment
    1 = 3 // [error: "not assignable"]
    f() = 3 // [error: "not assignable"]
    let car: Car
    car = 3 // [error: "cannot assign.*'int'.*'Car'"]

    // member access
    3.engine // [error: "'int'.*not a struct"]
    car.wing // [error: "'wing'.*not.*member.*'Car'"]
    car.engine

    car.engine = car // [error: "cannot assign.*'Car'.*'int'"]

    // binary expressions
    (3 + car) // [error: "incompatible.*binary.*'int'.*'Car'"]
    (3 + car).wheel // [error: "incompatible.*binary.*'int'.*'Car'"]
    (car).wheel

    // function calls
    car = f()
    let i: int
    i = f() // [error: "cannot assign.*'Car'.*'int'"]
    f() + g() // [error: "incompatible.*binary.*'Car'.*'int'"]
    f().engine
    f().wing // [error: "'wing'.*not.*member.*'Car'"]
    h(3, 4) // [error: "argument type mismatch"]
    
    // paren expr
    (f()).engine

    // ref and deref
    *i // [error: "dereference.*'int'"]
    let ptr: *int
    *ptr = 3
    *ptr = car // [error: "cannot assign.*'Car'.*'int'"]
    ptr = &i
    &24 // [error: "take address of an rvalue"]
    &g() // [error: "take address of an rvalue"]

    let pcar: *Car
    (*pcar).wheel
    *(pcar.wheel) // [error: "'\*Car'.*not a struct"]
}
