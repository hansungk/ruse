struct S {
    ptr: var &int
    ip: &int
}

func lifetime() {
    var x: &int // TODO: 'let' should be legal too
    let a = 42
    {
        let a = 4
        x = &a
    }
    *x // ERROR: 'a' does not live long enough

    var y: &int
    {
        let a = 4
        let s = S {.ip = &a}
        y = s.ip
    }
    *y
}

func f(ptr: &int) {
}

func fs(s: S) {
}

func multiple_borrows() {
    var a = 42
    {
        let x = &a
        let y = &a // ERROR: cannot borrow 'a' more than once
    }
    {
        // previous borrow should be dropped
        let x = &a
    }
    {
        let x = &a
        &a // ERROR: cannot borrow 'a' more than once
        S {.ptr = var &a} // ERROR: cannot borrow 'a' more than once
    }
    {
        let s1 = S {.ptr = var &a}
        // copy makes a new borrow
        // Note: this is caught in the type check phase.
        // let s2 = s1
    }
    {
        let x = &a
        f(&a) // ERROR: cannot borrow 'a' more than once
    }
    {
        let x = &a
        fs(S{.ptr = var &a}) // ERROR: cannot borrow 'a' more than once
        // fs(&S{.ptr = var &a}) // TODO: type check error
    }
}

struct StackRef {
    a: int
}

func stack_ref() -> &int {
    let x = 3
    return &x // ERROR: TODO: lifetime error

    let s = StackRef {.a = 3}
    {
        return &s.a // ERROR: TODO: lifetime error
    }
    {
        // indirect reference to a stack variable
        let p = &s.a
        return p // ERROR: TODO: lifetime error
    }
}
