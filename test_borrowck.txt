struct S {
    ptr: var &int
    ip: &int
}

func lifetime() {
    var x: &int
    let a = 42 // to confuse things more...
    {
        let a = 4
        x = &a
    }
    x // ERROR: 'a' does not live long enough

    var y: &int
    {
        let a = 4
        let s = S {.ip = &a}
        y = s.ip
    }
    y // ERROR: 'a' does not live long enough

    struct Val {
        a: int
    }

    var z: &int
    {
        var v = Val {.a = 3}
        z = &v.a
    }
    z // ERROR: 'v' does not live long enough
}

func move() {
    struct Copyable {
        m: int
    }

    var x: &int
    var c_out: Copyable
    {
        let c = Copyable {.m = 3}
        c_out <- c
        c // ERROR: use of moved value
        c.m // ERROR: use of moved value
    }

    {
        let c = Copyable {.m = 3}
        let p = &c
        let c2 = *p // ERROR: cannot move out of '\*p' because it will invalidate 'p'

        struct CC {
            m: Copyable
        }

        let cc = CC {.m = c}
        let ccp = &cc
        let cc2 = (*ccp).m // ERROR: cannot move out of '(\*ccp).m' because it will invalidate 'ccp'
    }
    
    {
        let c = Copyable {.m = 3}
        let p = &c
        c_out <- c // ERROR: cannot move out of 'c' because it is borrowed
    }

    // Built-in types should be exempt.
    {
        let a = 42
        let b = a
        a
    }
}

func f(ptr: &int) {
}

func fs(s: S) {
}

func multiple_borrows() {
    var a = 42
    {
        let x = &a
        let y = &a // ERROR: cannot borrow 'a' more than once
    }
    {
        // previous borrow should be dropped
        let x = &a
    }
    {
        let x = &a
        &a // ERROR: cannot borrow 'a' more than once
        S {.ptr = var &a} // ERROR: cannot borrow 'a' more than once
    }
    {
        let s1 = S {.ptr = var &a}
        // copy makes a new borrow
        // Note: this is caught in the type check phase.
        // let s2 = s1
    }
    {
        let x = &a
        f(&a) // ERROR: cannot borrow 'a' more than once
    }
    {
        let x = &a
        fs(S{.ptr = var &a}) // ERROR: cannot borrow 'a' more than once
    }
}

struct StackRef {
    a: int
}

func stack_ref() -> &int {
    let empty_ref: &int
    return empty_ref // ERROR: TODO: null borrow

    let x = 3
    return &x // ERROR: TODO: return lifetime error

    let s = StackRef {.a = 3}
    {
        return &s.a // ERROR: TODO: return lifetime error
    }
    {
        // indirect reference to a stack variable
        let p = &s.a
        return p // ERROR: TODO: return lifetime error
    }
    // TODO: return S {.a = &a}
}
